/***

  Olive - Non-Linear Video Editor
  Copyright (C) 2021 Olive Team

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

***/

#include "subtitleparams.h"

#include <QCoreApplication>

namespace olive {

QString SubtitleParams::GetEncodingName(Encoding encoding)
{
  switch (encoding) {
  case kISO8859_1:
    return QCoreApplication::translate("SubtitleParams", "ASCII/ISO 8859-1");
  case kWindows1252:
    return QCoreApplication::translate("SubtitleParams", "Windows-1252");
  case kUTF8:
    return QCoreApplication::translate("SubtitleParams", "UTF-8");
  case kUTF8WithBOM:
    return QCoreApplication::translate("SubtitleParams", "UTF-8 with BOM");
  case kUTF16LE:
    return QCoreApplication::translate("SubtitleParams", "UTF-16LE");
  case kUTF16BE:
    return QCoreApplication::translate("SubtitleParams", "UTF-16BE");
  case kEncodingInvalid:
  case kEncodingCount:
    break;
  }

  return QCoreApplication::translate("SubtitleParams", "Unknown");
}

bool SubtitleParams::EncodingHasUnicodeBOM(Encoding encoding)
{
  switch (encoding) {
  case kUTF8WithBOM:
  case kUTF16LE:
  case kUTF16BE:
    return true;

  case kISO8859_1:
  case kWindows1252:
  case kUTF8:
  case kEncodingInvalid:
  case kEncodingCount:
    break;
  }

  return false;
}

QByteArray SubtitleParams::GetUnicodeBOM(Encoding encoding)
{
  QByteArray arr;

  if (encoding == kUTF8WithBOM) {
    arr.resize(3);
    arr[0] = 0xEF;
    arr[1] = 0xBB;
    arr[2] = 0xBF;
  } else if (encoding == kUTF16LE) {
    arr.resize(2);
    arr[0] = 0xFF;
    arr[1] = 0xFE;
  } else if (encoding == kUTF16BE) {
    arr.resize(2);
    arr[0] = 0xFE;
    arr[1] = 0xFF;
  }

  return arr;
}

const char *SubtitleParams::GetQTextStreamCodec(Encoding encoding)
{
  switch (encoding) {
  case SubtitleParams::kISO8859_1:
    return "ISO 8859-1";
  case SubtitleParams::kWindows1252:
    return "Windows-1252";
  case SubtitleParams::kUTF8:
  case SubtitleParams::kUTF8WithBOM:
    return "UTF-8";
  case SubtitleParams::kUTF16LE:
    return "UTF-16LE";
  case SubtitleParams::kUTF16BE:
    return "UTF-16BE";
  case SubtitleParams::kEncodingInvalid:
  case SubtitleParams::kEncodingCount:
    break;
  }

  return nullptr;
}

QString SubtitleParams::GenerateASSHeader()
{
  // NOTE: We'll probably implement more customization as we support ASS better. Right now, we only
  //       natively support SRT and only make this header because FFmpeg requires it.
  static const int kAssDefaultPlayResX = 384;
  static const int kAssDefaultPlayResY = 288;
  static const QString kAssDefaultFont = QStringLiteral("Arial");
  static const int kAssDefaultFontSize = 16;
  static const int kAssDefaultPrimaryColor = 0xFFFFFF; // White
  static const int kAssDefaultSecondaryColor = 0xFFFFFF; // White
  static const int kAssDefaultOutlineColor = 0x000000; // Black
  static const int kAssDefaultBackColor = 0x000000; // Black
  static const int kAssBold = 0;
  static const int kAssItalic = 0;
  static const int kAssUnderline = 0;
  static const int kAssStrike = 0;
  static const int kAssBorderStyle = 1;
  static const int kAssAlignment = 2;

  static const QString kFormatHeader = QStringLiteral(
      "[Script Info]\r\n"
      "; Script generated by %1 %2\r\n"
      "ScriptType: v4.00+\r\n"
      "PlayResX: %3\r\n"
      "PlayResY: %4\r\n"
      "ScaledBorderAndShadow: yes\r\n"
      "\r\n"

      /* ASSv4 header */
      "[V4+ Styles]\r\n"
      "Format: Name, "
      "Fontname, Fontsize, "
      "PrimaryColour, SecondaryColour, OutlineColour, BackColour, "
      "Bold, Italic, Underline, StrikeOut, "
      "ScaleX, ScaleY, "
      "Spacing, Angle, "
      "BorderStyle, Outline, Shadow, "
      "Alignment, MarginL, MarginR, MarginV, "
      "Encoding\r\n"

      "Style: "
      "Default,"                /* Name */
      "%5,%6,"                  /* Font{name,size} */
      "&H%7,&H%8,&H%9,&H%10,"   /* {Primary,Secondary,Outline,Back}Colour */
      "%11,%12,%13,%14,"        /* Bold, Italic, Underline, StrikeOut */
      "100,100,"                /* Scale{X,Y} */
      "0,0,"                    /* Spacing, Angle */
      "%15,1,0,"                /* BorderStyle, Outline, Shadow */
      "%16,10,10,10,"           /* Alignment, Margin[LRV] */
      "0\r\n"                   /* Encoding */

      "\r\n"
      "[Events]\r\n"
      "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n"
  );

  return kFormatHeader.arg(QCoreApplication::applicationName(),
                           QCoreApplication::applicationVersion(),
                           QString::number(kAssDefaultPlayResX),
                           QString::number(kAssDefaultPlayResY),
                           kAssDefaultFont,
                           QString::number(kAssDefaultFontSize),
                           QString::number(kAssDefaultPrimaryColor, 16),
                           QString::number(kAssDefaultSecondaryColor, 16),
                           QString::number(kAssDefaultOutlineColor, 16),
                           QString::number(kAssDefaultBackColor, 16),
                           QString::number(kAssBold),
                           QString::number(kAssItalic),
                           QString::number(kAssUnderline),
                           QString::number(kAssStrike),
                           QString::number(kAssBorderStyle),
                           QString::number(kAssAlignment)
  );
}

}
